
CompletableFuture 相对于 Future 具有以下优势
1. 为快速创建、连接依赖和组合多个 Future 提供了大量的便利方法。
2. 提供了适合各种开发场景的回调函数，它还提供了非常全面的异常处理支持。
3. 无缝衔接和 Lambda 表达式和 Stream API。
4. 真正意义上把异步编程、函数式编程和响应式编程多种高阶编程思想集于一身，设计上更优雅。

## 创建异步任务
1. runAsync
2. supplyAsync
3. 异步任务中的线程池
4. 异步编程思想

### runAsync() 是并发还是并行执行？
* `CompletableFuture/src/main/java/com/ylqi007/createcompletablefuture/RunAsyncDemo03.java`

* 单核CPU：两个线程使用同一个core，两个线程轮流使用一个CPU core --> 并发
* 多核CPU：core1 处理 main 线程，core2 处理 ForkJoinPool.common-worker-1 线程 --> 异步任务并行执行
* 重点：作为开发者，只要清楚如何开启异步任务，CPU硬件会把异步任务合理分配给CPU上的 core 处理


## 异步任务中的线程池
* 默认线程池: ForkJoinPool
* 用户自定义线程池: Executor

最佳实践：创建属于自己的业务线程池。
如果所有的`CompletableFuture`都共享一个线程池，那么一旦有异步任务执行很慢的IO操作，就会导致线程池中所有线程都阻塞的IO操作上，从而造成线饥饿，进而影响整个系统的性能。
所以强烈建议，要根据不同的业务类型创建不同的线程池，以避免相互干扰。

## 异步编程思想
对**线程的创建**和**线程负责的任务**进行解耦合，这样带来的好处就是
* 线程的创建和启动全部交给线程池负责
* 具体任务的编写就交给程序员，专人专事

作为一个开发者，只需要有一个意识：
开发者只需要把耗时的操作交给 CompletableFuture 开启一个异步任务，然后继续关注主线程业务，当异步任务运行完成时会通知朱线程它的运行结果。
我们把具有了这种编程思想的开发称之为**异步编程思想**。


